// const SignedMessage = Record({
//   principal: Principal,
//   signature: blob,
//   messageHash: blob,
// });

// getPrincipalSigned: update([], SignedMessage, async () => {
//   const crypto = require("crypto");

//   const encoder = new TextEncoder();

//   const caller = ic.caller();
//   const callerBytes = caller.toUint8Array();
//   const objectToSign = {
//     principal: caller,
//   };

//   const objectToSignString = JSON.stringify(objectToSign);
//   const hash = crypto.createHash("sha256");
//   hash.update(objectToSignString);
//   const objectToSignHash = new Uint8Array(hash.digest());

//   const signatureResult = await ic.call(managementCanister.sign_with_ecdsa, {
//     args: [
//       {
//         message_hash: objectToSignHash,
//         derivation_path: [callerBytes],
//         key_id: {
//           curve: { secp256k1: null },
//           name: "dfx_test_key",
//         },
//       },
//     ],
//     cycles: 10n,
//   });

//   return {
//     publicKey: await getPublicKey(),
//     signature: signatureResult.signature,
//     principal: caller,
//     messageHash: objectToSignHash,
//   };
// }),

// async function getPublicKey() {
//   const publicKeyResult = await ic.call(managementCanister.get_public_key, {
//     args: [
//       {
//         key_id: {
//           curve: { secp256k1: null },
//           name: "dfx_test_key",
//         },
//       },
//     ],
//   });

//   return publicKeyResult.public_key;
// }
